import {
  AthenaClient,
  StartQueryExecutionCommand,
  GetQueryExecutionCommand,
  GetQueryResultsCommand,
  QueryExecutionState
} from '@aws-sdk/client-athena'
import config from 'config'
import delay from 'lib/delay'
import { apiLogger as logger } from 'lib/logger'

const ATHENA_RESULT_SIZE = 1000
const DELAY_INTERVAL = 500

// Init client
const athenaClient = new AthenaClient({
  credentials: {
    accessKeyId: config.AWS_ACCESS_KEY_ID,
    secretAccessKey: config.AWS_SECRET_ACCESS_KEY,
    sessionToken: config.AWS_SESSION_TOKEN
  },
  region: config.AWS_REGION
})

/**
 * @description Execute for generating queryExecutionId
 * @async
 * @function
 * @param {string} query Athena query
 * @returns {string | undefined}
 */
async function createQueryExecution(query: string): Promise<string | undefined> {
  try {
    const command = new StartQueryExecutionCommand({
      QueryString: query,
      ResultConfiguration: { OutputLocation: config.AWS_ATHENA_OUTPUT_LOCATION },
      QueryExecutionContext: { Database: config.AWS_ATHENA_DB }
    })

    const data = await athenaClient.send(command)

    logger.info(`Athena query created with id: ${data.QueryExecutionId}`)

    return data.QueryExecutionId
  } catch (err) {
    logger.error('Error creating Athena query: ', err)

    throw err
  }
}

/**
 * @description  check query status till it is not active.
 * @async
 * @function
 * @param {string} queryId Athena query id
 * @returns {QueryExecutionState}
 */
async function checkQueryStatus(queryId: string | undefined): Promise<QueryExecutionState> {
  try {
    const command = new GetQueryExecutionCommand({ QueryExecutionId: queryId })

    const data = await athenaClient.send(command)
    const state = <QueryExecutionState>data.QueryExecution?.Status?.State ?? QueryExecutionState.QUEUED

    if (state === QueryExecutionState.CANCELLED || state === QueryExecutionState.FAILED) {
      throw new Error(`QueryExecutionCommand error: ${data.QueryExecution?.Status?.StateChangeReason}`)
    }

    logger.info(`Athena query ${queryId} status: ${state}`)

    return state
  } catch (err) {
    logger.error('Error checking Athena query status: ', err)

    throw new Error(`Query status error: ${QueryExecutionState.FAILED}`)
  }
}

/**
 * @description wait until the query execution complete or fails
 * @async
 * @function
 * @param {string} queryId Athena query id
 * @returns {void}
 */
async function waitForQueryExecution(queryId: string | undefined): Promise<void> {
  try {
    const state = await checkQueryStatus(queryId)

    if ([QueryExecutionState.QUEUED, QueryExecutionState.RUNNING].includes(state)) {
      // waiting 1 second.
      delay(DELAY_INTERVAL)

      return waitForQueryExecution(queryId)
    }
  } catch (err) {
    logger.error('Error waiting for Athena query: ', err)

    throw err
  }
}

/**
 * @description Generating result based on queryExecutionId
 * @async
 * @function
 * @param {string} queryId Athena query id
 * @param page A token generated by the Athena service that specifies where to continue pagination
 * @param max Maximum number of results to return
 * @returns {AthenaQueryResponse}
 */
async function getQueryResult<T>(
  queryId: string | undefined,
  page?: string | undefined,
  max = ATHENA_RESULT_SIZE
): Promise<T[]> {
  const response: T[] = []

  try {
    const command = new GetQueryResultsCommand({
      QueryExecutionId: queryId,
      MaxResults: max,
      NextToken: page
    })
    const data = await athenaClient.send(command)
    const rows = data.ResultSet?.Rows ?? []
    const header: string[] = (data.ResultSet?.ResultSetMetadata?.ColumnInfo ?? []).map((column) => column?.Name ?? '')

    if (!header) {
      throw new Error('Invalid Athena query result headers.')
    }

    const firstRow = (rows[0].Data ?? []).map((n) => n.VarCharValue)

    if (firstRow.join('') === header.join('')) {
      rows.shift()
    }

    rows.forEach((item) => {
      const values = (item?.Data ?? []).map((n) => n.VarCharValue)

      response.push(
        header.reduce((acc: T, key: string, idx: number) => {
          acc[key] = values[idx]
          return acc
        }, {} as T)
      )
    })

    if (data.NextToken) {
      const nextData = await getQueryResult<T>(queryId, data.NextToken)

      response.push(...nextData)
    }
  } catch (err) {
    logger.error('Error getting Athena query result: ', err)
  }

  return response
}

/**
 * @description Execute a query and return a result.
 * @async
 * @function
 * @param {string} query The SQL query statements to be executed
 */
export async function makeQuery<T>(query: string): Promise<T[]> {
  try {
    const queryId = await createQueryExecution(query)

    if (!queryId) {
      throw new Error(`Invalid query: ${query}`)
    }

    await waitForQueryExecution(queryId)

    return getQueryResult(queryId)
  } catch (err) {
    logger.error('Error getting Athena data: ', err)

    throw err
  }
}
